@PACKAGE_INIT@

set(@META_PROJECT_VARNAME@_HAS_LIBS "@BUILD_SHARED_LIBS@")
set(@META_PROJECT_VARNAME@_LIBS "@META_PROJECT_NAME@")
set(@META_PROJECT_VARNAME@_HAS_STATIC_LIBS "@BUILD_STATIC_LIBS@")
set(@META_PROJECT_VARNAME@_STATIC_LIBS "@META_PROJECT_NAME@.a")
set(@META_PROJECT_VARNAME@_STATIC_LIBS_DEPENDS @META_LIB_DEPENDS@)
set(@META_PROJECT_VARNAME@_INCLUDE_DIRS "@PACKAGE_HEADER_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME@_BIN_DIR "@PACKAGE_BIN_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME@_LIB_DIR "@PACKAGE_LIB_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME@_MODULE_DIRS "@PACKAGE_CMAKE_MODULE_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME@_CONFIG_DIRS "@PACKAGE_CMAKE_CONFIG_INSTALL_DESTINATION@")

macro(use_@META_PROJECT_VARNAME@)
    include_directories(BEFORE SYSTEM ${@META_PROJECT_VARNAME@_INCLUDE_DIRS})
    link_directories(${@META_PROJECT_VARNAME@_LIB_DIR})
    # add library to list of libraries to link against when building dynamic libraries or applications
    if(@META_PROJECT_VARNAME@_HAS_STATIC_LIBS AND ((NOT ARGV0 AND ((STATIC_LINKAGE AND "${META_PROJECT_TYPE}" STREQUAL "application") OR (STATIC_LIBRARY_LINKAGE AND ("${META_PROJECT_TYPE}" STREQUAL "" OR "${META_PROJECT_TYPE}" STREQUAL "library")))) OR ("${ARGV0}" STREQUAL "STATIC")))
        list(APPEND LIBRARIES ${@META_PROJECT_VARNAME@_STATIC_LIBS} ${@META_PROJECT_VARNAME@_STATIC_LIBS_DEPENDS})
    elseif(@META_PROJECT_VARNAME@_HAS_LIBS AND (NOT ARGV0 OR ("${ARGV0}" STREQUAL "SHARED")))
        list(APPEND LIBRARIES ${@META_PROJECT_VARNAME@_LIBS})
    else()
        message(ERROR "Specified linkage ${ARGV0} is not available.")
    endif()
    # add library to list of libraries to be provided as transitive dependencies when building static libraries
    list(APPEND STATIC_LIBRARIES ${@META_PROJECT_VARNAME@_STATIC_LIBS} ${@META_PROJECT_VARNAME@_STATIC_LIBS_DEPENDS})
    # make CMake modules of the project available
    list(APPEND CMAKE_MODULE_PATH ${@META_PROJECT_VARNAME@_MODULE_DIRS})
endmacro()
