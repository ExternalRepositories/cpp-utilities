@PACKAGE_INIT@

# provide meta-data
set(@META_PROJECT_NAME@_varname "@META_PROJECT_VARNAME_UPPER@")
set(@META_PROJECT_VARNAME_UPPER@_DISPLAY_NAME "@META_APP_NAME@")
set(@META_PROJECT_VARNAME_UPPER@_AUTHOR "@META_APP_AUTHOR@")
set(@META_PROJECT_VARNAME_UPPER@_VERSION "@META_APP_VERSION@")
set(@META_PROJECT_VARNAME_UPPER@_VERSION_MAJOR "@META_VERSION_MAJOR@")
set(@META_PROJECT_VARNAME_UPPER@_VERSION_MINOR "@META_VERSION_MINOR@")
set(@META_PROJECT_VARNAME_UPPER@_VERSION_PATCH "@META_VERSION_PATCH@")
set(@META_PROJECT_VARNAME_UPPER@_GIT_REV_COUNT "@META_GIT_REV_COUNT@")
set(@META_PROJECT_VARNAME_UPPER@_GIT_LAST_COMMIT_ID "@META_GIT_LAST_COMMIT_ID@")
set(@META_PROJECT_VARNAME_UPPER@_URL "@META_APP_URL@")
set(@META_PROJECT_VARNAME_UPPER@_DESCRIPTION "@META_APP_DESCRIPTION@")
set(@META_PROJECT_VARNAME_UPPER@_LICENSE "@META_PROJECT_LICENSE@")

# define general config
set(@META_PROJECT_VARNAME_UPPER@_IS_HEADER_ONLY @META_HEADER_ONLY_LIB@)
set(@META_PROJECT_VARNAME_UPPER@_INCLUDE_DIRS "@PACKAGE_HEADER_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_BIN_DIR "@PACKAGE_BIN_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_LIB_DIR "@PACKAGE_LIB_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_MODULE_DIRS "@PACKAGE_CMAKE_MODULE_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_CONFIG_DIRS "@PACKAGE_CMAKE_CONFIG_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_PRIVATE_QT_MODULES "@QT_MODULES@")
set(@META_PROJECT_VARNAME_UPPER@_PRIVATE_KF_MODULES "@KF_MODULES@")
set(@META_PROJECT_VARNAME_UPPER@_PUBLIC_QT_MODULES "@META_PUBLIC_QT_MODULES@")
set(@META_PROJECT_VARNAME_UPPER@_PUBLIC_KF_MODULES "@META_PUBLIC_KF_MODULES@")
set(@META_PROJECT_VARNAME_UPPER@_REQUIRED_PACKAGES "@INTERFACE_REQUIRED_PACKAGES@")
set(@META_PROJECT_VARNAME_UPPER@_HAS_QT_TRANSLATION_FILES @APP_SPECIFIC_QT_TRANSLATIONS_AVAILABLE@)
set(@META_PROJECT_VARNAME_UPPER@_QT_RESOURCES @QT_RESOURCES@)

# define library config, add imported target
set(@META_PROJECT_VARNAME_UPPER@_PACKAGE "@META_PROJECT_NAME@@META_CONFIG_SUFFIX@")
set(@META_PROJECT_VARNAME_UPPER@_LIB "@META_TARGET_NAME@")
set(@META_PROJECT_VARNAME_UPPER@_LIB_IS_SHARED "@BUILD_SHARED_LIBS@")
set(@META_PROJECT_VARNAME_UPPER@_STATIC_LINKAGE "@STATIC_LINKAGE_CONFIGURED@")
set(PKG_CONFIG_@META_TARGET_NAME@ "@META_PROJECT_NAME@@META_CONFIG_SUFFIX@")
if(NOT TARGET "${@META_PROJECT_VARNAME_UPPER@_LIB}")
    include("${CMAKE_CURRENT_LIST_DIR}/@META_PROJECT_NAME@@META_CONFIG_SUFFIX@Targets.cmake")

    # find all required packages; prefer static libraries if project was configured this way during its build
    if (@META_PROJECT_VARNAME_UPPER@_STATIC_LINKAGE)
        set(@META_PROJECT_VARNAME_UPPER@_DEFAULT_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
        if (WIN32)
            set(CMAKE_FIND_LIBRARY_SUFFIXES .a .lib)
        else ()
            set(CMAKE_FIND_LIBRARY_SUFFIXES .a)
        endif ()
    endif ()
    foreach (_REQUIRED_PACKAGE ${@META_PROJECT_VARNAME_UPPER@_REQUIRED_PACKAGES})
        string(REGEX MATCH _REQUIRED_PACKAGE_MATCH "(.*)-([^-]*)" "${_REQUIRED_PACKAGE}")
        if (_REQUIRED_PACKAGE_MATCH)
            find_package("${CMAKE_MATCH_1}" "${CMAKE_MATCH_2}" REQUIRED)
        else ()
            find_package("${_REQUIRED_PACKAGE}" REQUIRED)
        endif()
    endforeach()
    if (@META_PROJECT_VARNAME_UPPER@_STATIC_LINKAGE)
        set(CMAKE_FIND_LIBRARY_SUFFIXES ${@META_PROJECT_VARNAME_UPPER@_DEFAULT_CMAKE_FIND_LIBRARY_SUFFIXES})
        unset(@META_PROJECT_VARNAME_UPPER@_DEFAULT_CMAKE_FIND_LIBRARY_SUFFIXES)
    endif ()
endif()

# define function to ease use of library in projects following conventions of c++utilities' build script
function(use_@META_PROJECT_VARNAME@)
    # make CMake modules of the project available
    list(APPEND CMAKE_MODULE_PATH "${@META_PROJECT_VARNAME_UPPER@_MODULE_DIRS}")
    set(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH}" PARENT_SCOPE)

    # parse arguments
    include(3rdParty)
    parse_arguments_for_use_functions(${ARGN})

    # link against library (also "link" against header-only libs to get compile defs and interface link libs)
    link_directories(${@META_PROJECT_VARNAME_UPPER@_LIB_DIR})
    set("${ARGS_LIBRARIES_VARIABLE}" "${${ARGS_LIBRARIES_VARIABLE}};${@META_PROJECT_VARNAME_UPPER@_LIB}" PARENT_SCOPE)
    set("${ARGS_PACKAGES_VARIABLE}" "${${ARGS_PACKAGES_VARIABLE}};${@META_PROJECT_VARNAME_UPPER@_PACKAGE}" PARENT_SCOPE)

    # add required Qt and KF modules
    set(IMPORTED_QT_MODULES
        ${IMPORTED_QT_MODULES}
        ${@META_PROJECT_VARNAME_UPPER@_PUBLIC_QT_MODULES}
        ${@META_PROJECT_VARNAME_UPPER@_PRIVATE_QT_MODULES}
        PARENT_SCOPE
    )
    set(IMPORTED_KF_MODULES
        ${IMPORTED_KF_MODULES}
        ${@META_PROJECT_VARNAME_UPPER@_PUBLIC_KF_MODULES}
        ${@META_PROJECT_VARNAME_UPPER@_PRIVATE_KF_MODULES}
        PARENT_SCOPE
    )

    # add required translations to APP_SPECIFIC_QT_TRANSLATION_FILES_ARRAY
    if(@META_PROJECT_VARNAME_UPPER@_HAS_QT_TRANSLATION_FILES)
        set(APP_SPECIFIC_QT_TRANSLATION_FILES "${APP_SPECIFIC_QT_TRANSLATION_FILES};@META_PROJECT_NAME@@META_CONFIG_SUFFIX@" PARENT_SCOPE)
    endif()

    # add Qt resources if it is a static library
    if (NOT @META_PROJECT_VARNAME_UPPER@_LIB_IS_SHARED)
        set(STATIC_LIBRARIES_QT_RESOURCES "${STATIC_LIBRARIES_QT_RESOURCES};${@META_PROJECT_VARNAME_UPPER@_QT_RESOURCES}" PARENT_SCOPE)
    endif()
endfunction()
